\section*{Demonstration}

Running the following application is simple and easy to use. The user has to first edit a configuration file which is named \verb|gofr_config.py|. In this configuration file, the user specifies the first input source and second input source. If the second input source is not applicable, the second field is left empty. It should be noted that the URL can be a local file or a file on a server. The user can also specify whether all the atomsets in the data need to be considered or just the first atomset. The last 5 variables are the important parameters set by the user which is used in the gofr program. These variables represent important quantities such as the atoms being compared and the stepsize to be recorded. An example configuration file (before the application is run, might look like this):

\begin{minted}{python}
# Configuration file
first_input_source = "./input_files/md120_short.r"
second_input_source = "./input_files/md120_short2.r"
all_or_first = "a" # a means all and f means first

first_molecule_name = "H"
second_molecule_name = "H"
rmax = 5
dr = 0.05
stepsize = 1
\end{minted}


After this step is performed, the user can then run the application via python. In this case, the user types ``python run\_gofr.py'' in the terminal or command prompt. This program reads the configuration parameters from the file, extracts the data from the input xml source(s), and runs the gofr algorithm behind the scenes. As a result an output text file called \verb|cum_counts.txt| and a second file (if applicable), \verb|cum_counts2.txt| is outputted for the visualization phase. This file represents the cumulative counts recorded at every $nth$ stepsize. 


\begin{minted}{bash}
[~/Documents/Radial-Distribution-Calculator]$ python run_gofr.py
....
....
\end{minted}

After this phase, the gofr algorithm is run on the given data and the intermediate values are recorded for visualization. The second step is as easy as the first and merely involves running the \verb|visualizer.py| script. This script is executed in a very similar manner to the run\_gofr.py script, however the user can specify certain options such as x and y limits if needed. For instance, \verb| python visualizer.py cum_counts.txt -x 5 -y 5| will generate a output html page with $x$ and $y$ bounds of $5$ and $5$. If the user does not specify $x$ and $y$, then the visualizer automatically sets the bounds for the diagram.

\begin{minted}{bash}
[~]$ ./visualizer.py intr_files/cum_counts.txt intr_files/cum_counts2.txt 
\end{minted}


\subsection*{Interactivity}

A slider is present on the top of the output html webpage. Using this feature, the user can select the appropriate range (starting frame number and the ending frame number) and effectively analyze the configuration. When the user releases the sliders, the graph changes accordingly. Below is a diagram of what the slider looks like:


\includegraphics[scale=0.50]{images/slider}


Below are two examples of applications run using the following scripts. The first demonstration involves analyzing water and the following involves analyzing silicon. 

Examples of water with two short simulations (to prove that the application works for two input sources).

\begin{figure}[H]
\centering
\includegraphics[scale=0.30]{images/two_graphs_HH}
\caption{This figure represents the $G(r)$ function for a hydrogen vs hydrogen molecule for two different atomsets. As can be observed, there is a enormous peak initially followed by a few ups and downs. The peak around 1.5 suggests that there is a high probability of finding another Hydrogen atom.}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.30]{images/two_graphs_OH}
\caption{This figure represents the $G(r)$ function for a Oxygen and Hydrogen molecule for two different atomsets. This function varies from the H vs H as can be observed from the diagram.}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.30]{images/two_graphs_OO}
\caption{This figure represents the $G(r)$ function for a Oxygen and Oxygen molecule for two different atomsets. It is extremely useful as it portrays the behavior of oxygen atoms in the water molecule.}
\end{figure}

% \begin{figure}[h!]

% \end{figure}

Examples of water with one large simulation

\begin{figure}[H]
\centering
\includegraphics[scale=0.30]{images/one_graph_HH}
\caption{This figure represents the $G(r)$ function for a larger simulation (namely 2000 atomsets). As can be observed from the previous diagrams, the curve is smoother.}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.30]{images/one_graph_OH}
\caption{Figures can be interpreted similar to the previous diagrams.}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[scale=0.30]{images/one_graph_OO}
\caption{Figures can be interpreted similar to the previous diagrams.}
\end{figure}

Explanation of silicon (molecules being compared are Si vs Si).

\begin{figure}[H]
\centering
\includegraphics[scale=0.30]{images/one_graph_SiSi}
\caption{This figure represents the $G(r)$ function run on an even larger simulation (namely $10,000$ atomsets). The two elements being compared here are Silicon and Silicon.}
\end{figure}

As we can see, the application is scalable and produces the correct results consistently. The first example had $20$ atomsets, the second $2,000$, and the third $10,000$ and the visualization app worked as intended.
